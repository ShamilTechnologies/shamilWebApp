/// File: lib/features/access_control/service/access_control_sync_service.dart
/// --- UPDATED: Handles updated Hive models, uses governorateId for partitioned queries ---
/// --- UPDATED: Refactored syncAllData for partitioning ---
library;

import 'dart:async';
import 'package:hive/hive.dart';
import 'package:hive_flutter/hive_flutter.dart'; // Import Hive Flutter
import 'package:flutter/foundation.dart'; // For ValueNotifier
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:uuid/uuid.dart'; // For generating log keys
import 'package:path_provider/path_provider.dart'; // Needed for Hive init path

// *** UPDATED: Import updated Hive Models ***
import 'package:shamil_web_app/features/access_control/data/local_cache_models.dart';
// *** UPDATED: Import updated Firestore Models (Reservation, Subscription, AccessLog) ***
import 'package:shamil_web_app/features/dashboard/data/dashboard_models.dart'
    show Subscription, Reservation, AccessLog;
// *** UPDATED: Import updated ServiceProviderModel to get governorateId ***
import 'package:shamil_web_app/features/auth/data/service_provider_model.dart';

// Define Box names as constants
const String cachedUsersBoxName = 'cachedUsersBox';
const String cachedSubscriptionsBoxName = 'cachedSubscriptionsBox';
const String cachedReservationsBoxName =
    'cachedReservationsBox'; // Name uses updated CachedReservation type
const String localAccessLogsBoxName = 'localAccessLogsBox';

class AccessControlSyncService {
  // Singleton pattern
  static final AccessControlSyncService _instance =
      AccessControlSyncService._internal();
  factory AccessControlSyncService() => _instance;
  AccessControlSyncService._internal();

  // Hive Boxes (will be opened during init)
  Box<CachedUser>? _cachedUsersBox;
  Box<CachedSubscription>? _cachedSubscriptionsBox;
  // *** Uses updated (but structurally similar) CachedReservation model type ***
  Box<CachedReservation>? _cachedReservationsBox;
  Box<LocalAccessLog>? _localAccessLogsBox;

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final Uuid _uuid = const Uuid(); // For generating log keys

  /// Notifier for the UI to listen to sync status changes.
  final ValueNotifier<bool> isSyncingNotifier = ValueNotifier(false);

  // --- Box Getters (Provide access to opened boxes) ---
  Box<CachedUser> get cachedUsersBox {
    if (_cachedUsersBox == null || !_cachedUsersBox!.isOpen) {
      throw StateError(
        'CachedUsersBox not initialized or closed. Call init() first.',
      );
    }
    return _cachedUsersBox!;
  }

  Box<CachedSubscription> get cachedSubscriptionsBox {
    if (_cachedSubscriptionsBox == null || !_cachedSubscriptionsBox!.isOpen) {
      throw StateError('CachedSubscriptionsBox not initialized or closed.');
    }
    return _cachedSubscriptionsBox!;
  }

  // *** Uses updated CachedReservation model type ***
  Box<CachedReservation> get cachedReservationsBox {
    if (_cachedReservationsBox == null || !_cachedReservationsBox!.isOpen) {
      throw StateError('CachedReservationsBox not initialized or closed.');
    }
    return _cachedReservationsBox!;
  }

  Box<LocalAccessLog> get localAccessLogsBox {
    if (_localAccessLogsBox == null || !_localAccessLogsBox!.isOpen) {
      throw StateError('LocalAccessLogsBox not initialized or closed.');
    }
    return _localAccessLogsBox!;
  }
  // --- End Box Getters ---

  /// Initializes Hive, registers adapters, and opens boxes.
  Future<void> init() async {
    // Check if already initialized
    if (_cachedUsersBox != null && _cachedUsersBox!.isOpen) {
      print("AccessControlSyncService: Hive boxes already initialized.");
      return;
    }

    try {
      // Get directory for Hive storage
      final appDocumentDir = await getApplicationDocumentsDirectory();
      // Initialize Hive for Flutter (specifies storage directory)
      await Hive.initFlutter(appDocumentDir.path);

      // Register TypeAdapters (generated by build_runner)
      // Ensure these are registered only once
      if (!Hive.isAdapterRegistered(cachedUserTypeId)) {
        Hive.registerAdapter(CachedUserAdapter());
      }
      if (!Hive.isAdapterRegistered(cachedSubscriptionTypeId)) {
        Hive.registerAdapter(CachedSubscriptionAdapter());
      }
      if (!Hive.isAdapterRegistered(cachedReservationTypeId)) {
        // *** Uses adapter for the updated CachedReservation model ***
        Hive.registerAdapter(CachedReservationAdapter());
      }
      if (!Hive.isAdapterRegistered(localAccessLogTypeId)) {
        Hive.registerAdapter(LocalAccessLogAdapter());
      }

      print(
        "AccessControlSyncService: Hive TypeAdapters registered (or already were).",
      );

      // Open boxes
      _cachedUsersBox = await Hive.openBox<CachedUser>(cachedUsersBoxName);
      _cachedSubscriptionsBox = await Hive.openBox<CachedSubscription>(
        cachedSubscriptionsBoxName,
      );
      // *** Uses updated CachedReservation model type ***
      _cachedReservationsBox = await Hive.openBox<CachedReservation>(
        cachedReservationsBoxName,
      );
      _localAccessLogsBox = await Hive.openBox<LocalAccessLog>(
        localAccessLogsBoxName,
      );

      print("AccessControlSyncService: Hive boxes opened successfully.");
    } catch (e, stackTrace) {
      print(
        "!!! AccessControlSyncService: Failed to initialize Hive database: $e",
      );
      print(stackTrace);
      // Handle critical error - app might not function without cache
    }
  }

  /// Closes all opened Hive boxes.
  Future<void> close() async {
    print("AccessControlSyncService: Closing Hive boxes...");
    // Check if boxes are open before closing
    // Use await on close operations
    await _cachedUsersBox?.close();
    await _cachedSubscriptionsBox?.close();
    await _cachedReservationsBox?.close();
    await _localAccessLogsBox?.close();
    // await Hive.close(); // Closes Hive instance itself if needed (usually not required unless stopping Hive completely)
    print("AccessControlSyncService: Hive boxes closed.");
  }

  // --- Synchronization Methods ---

  /// Fetches latest data from Firestore and updates the local Hive cache.
  /// *** UPDATED: Requires governorateId to query partitioned reservations ***
  Future<void> syncAllData() async {
    // Ensure boxes are open
    if (!(_cachedUsersBox?.isOpen ?? false) ||
        !(_cachedSubscriptionsBox?.isOpen ?? false) ||
        !(_cachedReservationsBox?.isOpen ?? false)) {
      print(
        "AccessControlSyncService [syncAllData]: Cannot sync: Hive boxes not open.",
      );
      return;
    }
    if (isSyncingNotifier.value) {
      print(
        "AccessControlSyncService [syncAllData]: Sync already in progress.",
      );
      return;
    }

    final User? user = _auth.currentUser;
    if (user == null) {
      print(
        "AccessControlSyncService [syncAllData]: Cannot sync: User not authenticated.",
      );
      return;
    }
    final String providerId = user.uid;

    isSyncingNotifier.value = true;
    print(
      "AccessControlSyncService [syncAllData]: Starting data synchronization (Hive) for provider $providerId...",
    );

    String? governorateId; // Variable to hold the governorate ID

    try {
      // *** NEW: Get provider's governorateId - CRITICAL for partitioned query ***
      final providerDoc =
          await _firestore.collection("serviceProviders").doc(providerId).get();
      if (!providerDoc.exists) {
        throw Exception("Provider document not found for ID: $providerId");
      }
      // *** Use UPDATED ServiceProviderModel to parse ***
      final providerData = ServiceProviderModel.fromFirestore(providerDoc);
      governorateId = providerData.governorateId; // Extract governorateId

      if (governorateId == null || governorateId.isEmpty) {
        // *** Handle missing governorateId - Log warning and SKIP reservation sync ***
        print(
          "!!! AccessControlSyncService [syncAllData]: Cannot sync reservations: Provider's governorateId is missing or empty.",
        );
        // Proceed with subscription sync, but skip reservations.
      } else {
        print(
          "AccessControlSyncService [syncAllData]: Syncing with governorateId: $governorateId",
        );
      }

      // 1. Fetch Data from Firestore
      final now = DateTime.now();
      // Define time ranges for queries (adjust as needed for caching strategy)
      // Example: Cache active subs & reservations for today +/- a few days?
      final cacheWindowStart = DateTime(
        now.year,
        now.month,
        now.day,
      ).subtract(const Duration(days: 1)); // Example: From yesterday
      final cacheWindowEnd = DateTime(
        now.year,
        now.month,
        now.day,
        23,
        59,
        59,
      ).add(const Duration(days: 7)); // Example: Until a week from now

      // Fetch active subscriptions (assuming top-level collection)
      // Cache subscriptions expiring within the window or currently active
      final subsFuture =
          _firestore
              .collection("subscriptions")
              .where("providerId", isEqualTo: providerId)
              .where("status", isEqualTo: "Active")
              // Optional: Add expiry date filtering if needed
              // .where("expiryDate", isGreaterThanOrEqualTo: Timestamp.fromDate(cacheWindowStart))
              .get();

      // Fetch reservations ONLY if governorateId is available
      Future<QuerySnapshot<Map<String, dynamic>>>? resFuture;
      if (governorateId != null && governorateId.isNotEmpty) {
        // *** UPDATED: Query the partitioned path ***
        resFuture =
            _firestore
                .collection("reservations")
                .doc(governorateId) // Use governorateId
                .collection(providerId) // Use providerId
                .where(
                  "status",
                  whereIn: ["Confirmed", "Pending"],
                ) // Cache relevant statuses
                .where(
                  "dateTime",
                  isGreaterThanOrEqualTo: Timestamp.fromDate(cacheWindowStart),
                )
                .where(
                  "dateTime",
                  isLessThanOrEqualTo: Timestamp.fromDate(cacheWindowEnd),
                )
                // Note: orderBy("dateTime") might be needed if using startAfter for pagination later
                .get();
      } else {
        resFuture = null; // Skip reservation fetch
      }

      // Wait for fetches
      final List<dynamic> firestoreResults = await Future.wait([
        subsFuture,
        if (resFuture != null)
          resFuture
        else
          Future.value(null), // Include reservation future only if valid
      ], eagerError: true); // Stop if any essential fetch fails

      final QuerySnapshot subsSnapshot = firestoreResults[0];
      // Reservation snapshot might be null if fetch was skipped
      final QuerySnapshot<Map<String, dynamic>>? resSnapshot =
          firestoreResults[1] as QuerySnapshot<Map<String, dynamic>>?;

      // 2. Prepare data for Hive Boxes
      final Map<String, CachedUser> usersToCache = {};
      final Map<String, CachedSubscription> subsToCache = {};
      // *** Uses updated CachedReservation model type ***
      final Map<String, CachedReservation> resToCache = {};

      // Process Subscriptions
      for (var doc in subsSnapshot.docs) {
        try {
          // *** Use UPDATED Subscription model from dashboard_models.dart ***
          final sub = Subscription.fromSnapshot(doc);
          if (!usersToCache.containsKey(sub.userId)) {
            usersToCache[sub.userId] = CachedUser(
              userId: sub.userId,
              userName: sub.userName,
            );
          }
          if (sub.expiryDate != null) {
            // Ensure expiryDate is not null
            subsToCache[sub.id] = CachedSubscription(
              userId: sub.userId,
              subscriptionId: sub.id,
              planName: sub.planName,
              expiryDate: sub.expiryDate!.toDate(),
            );
          }
        } catch (e) {
          print(
            "AccessControlSyncService [syncAllData]: Error processing subscription ${doc.id}: $e",
          );
        }
      }

      // Process Reservations (only if snapshot exists)
      if (resSnapshot != null) {
        for (var doc in resSnapshot.docs) {
          try {
            // *** Use UPDATED Reservation model from dashboard_models.dart ***
            final res = Reservation.fromSnapshot(doc);
            if (!usersToCache.containsKey(res.userId)) {
              usersToCache[res.userId] = CachedUser(
                userId: res.userId,
                userName: res.userName,
              );
            }

            // *** Map UPDATED Reservation fields to EXISTING CachedReservation fields ***
            DateTime endTime =
                res.endTime ??
                res.startTime.add(
                  const Duration(hours: 1),
                ); // Calculate end time
            resToCache[res.id] = CachedReservation(
              userId: res.userId,
              reservationId: res.id,
              serviceName:
                  res.serviceName ??
                  'Reservation', // Use serviceName from model
              startTime: res.startTime, // Use startTime getter
              endTime: endTime, // Use calculated endTime
              typeString: res.type.name, // Use type enum name
              groupSize: res.groupSize, // Use groupSize from model
              // No need to map governorateId, isRecurring, typeSpecificData to cache for basic validation
            );
          } catch (e) {
            print(
              "AccessControlSyncService [syncAllData]: Error processing reservation ${doc.id}: $e",
            );
          }
        }
      } else {
        print(
          "AccessControlSyncService [syncAllData]: Skipping reservation processing as governorateId was missing or fetch failed.",
        );
      }

      // 3. Write to Hive Boxes (Atomic update using transaction or clear/putAll)
      // Clearing first ensures removal of stale data
      await cachedUsersBox.clear();
      await cachedSubscriptionsBox.clear();
      await cachedReservationsBox.clear();
      print("AccessControlSyncService [syncAllData]: Cleared old Hive cache.");

      await cachedUsersBox.putAll(usersToCache);
      await cachedSubscriptionsBox.putAll(subsToCache);
      await cachedReservationsBox.putAll(
        resToCache,
      ); // Uses updated CachedReservation type
      print(
        "AccessControlSyncService [syncAllData]: Hive cache update complete. Users: ${usersToCache.length}, Subs: ${subsToCache.length}, Res: ${resToCache.length}",
      );

      print(
        "AccessControlSyncService [syncAllData]: Data synchronization finished successfully.",
      );
    } catch (e, stackTrace) {
      print(
        "!!! AccessControlSyncService [syncAllData]: Error during data synchronization: $e\n$stackTrace",
      );
    } finally {
      isSyncingNotifier.value = false;
      print(
        "AccessControlSyncService [syncAllData]: Sync status notifier set to false.",
      );
    }
  }

  /// Reads unsynced logs from Hive and uploads them to Firestore.
  /// *** NOTE: Assumes accessLogs are NOT partitioned by governorate ***
  Future<void> syncAccessLogs() async {
    if (!(_localAccessLogsBox?.isOpen ?? false)) {
      print(
        "AccessControlSyncService [syncLogs]: Cannot sync logs: Hive box not open.",
      );
      return;
    }
    if (isSyncingNotifier.value) {
      print("AccessControlSyncService [syncLogs]: Sync already in progress.");
      return;
    }

    final User? user = _auth.currentUser;
    if (user == null) {
      print(
        "AccessControlSyncService [syncLogs]: Cannot sync logs: User not authenticated.",
      );
      return;
    }
    final String providerId = user.uid;

    isSyncingNotifier.value = true;
    print(
      "AccessControlSyncService [syncLogs]: Starting access log synchronization (Hive)...",
    );

    try {
      // 1. Find unsynced logs in Hive
      final List<MapEntry<dynamic, LocalAccessLog>> logsToSyncEntries =
          localAccessLogsBox
              .toMap()
              .entries
              .where((entry) => entry.value.needsSync)
              .toList();

      if (logsToSyncEntries.isEmpty) {
        print(
          "AccessControlSyncService [syncLogs]: No access logs need syncing.",
        );
        isSyncingNotifier.value = false; // Reset notifier
        return;
      }

      print(
        "AccessControlSyncService [syncLogs]: Found ${logsToSyncEntries.length} access logs to sync.",
      );

      // 2. Upload to Firestore (Batching)
      WriteBatch batch = _firestore.batch();
      List<MapEntry<dynamic, LocalAccessLog>> successfullyBatchedEntries = [];
      int batchCounter = 0;
      const int batchLimit = 400; // Firestore batch limit is 500

      for (int i = 0; i < logsToSyncEntries.length; i++) {
        final entry = logsToSyncEntries[i];
        final localLog = entry.value;

        // *** Use AccessLog model from dashboard_models.dart ***
        final firestoreLog = AccessLog(
          providerId: providerId,
          userId: localLog.userId,
          userName: localLog.userName,
          timestamp: Timestamp.fromDate(localLog.timestamp),
          status: localLog.status,
          method: localLog.method,
          denialReason: localLog.denialReason,
        );
        final Map<String, dynamic> firestoreLogData =
            firestoreLog.toMap(); // Use model's toMap

        // Assuming top-level collection for logs
        final docRef =
            _firestore.collection("accessLogs").doc(); // Firestore generates ID
        batch.set(docRef, firestoreLogData);
        successfullyBatchedEntries.add(entry);
        batchCounter++;

        if (batchCounter == batchLimit || i == logsToSyncEntries.length - 1) {
          await batch.commit();
          print(
            "AccessControlSyncService [syncLogs]: Committed batch of $batchCounter logs.",
          );
          // Start new batch if more logs remain
          if (i < logsToSyncEntries.length - 1) {
            batch = _firestore.batch();
            batchCounter = 0;
          }
        }
      }
      print(
        "AccessControlSyncService [syncLogs]: Successfully uploaded ${successfullyBatchedEntries.length} logs to Firestore.",
      );

      // 3. Update synced logs in Hive
      final Map<dynamic, LocalAccessLog> updates = {};
      for (var entry in successfullyBatchedEntries) {
        updates[entry.key] = entry.value.copyWith(needsSync: false);
      }
      await localAccessLogsBox.putAll(updates); // Update using original keys
      print(
        "AccessControlSyncService [syncLogs]: Updated ${updates.length} logs in local Hive cache as synced.",
      );

      print(
        "AccessControlSyncService [syncLogs]: Access log synchronization finished successfully.",
      );
    } catch (e, stackTrace) {
      print(
        "!!! AccessControlSyncService [syncLogs]: Error during access log synchronization: $e\n$stackTrace",
      );
    } finally {
      isSyncingNotifier.value = false;
      print(
        "AccessControlSyncService [syncLogs]: Sync status notifier set to false.",
      );
    }
  }

  // --- Method to save a new log entry locally ---
  Future<void> saveLocalAccessLog(LocalAccessLog log) async {
    if (!(_localAccessLogsBox?.isOpen ?? false)) {
      print(
        "AccessControlSyncService [saveLog]: Cannot save log: Hive box not open.",
      );
      return;
    }
    try {
      final String logKey = _uuid.v4(); // Generate unique key for Hive entry
      await localAccessLogsBox.put(logKey, log);
      print(
        "AccessControlSyncService [saveLog]: Saved local access log with key: $logKey",
      );
    } catch (e) {
      print(
        "!!! AccessControlSyncService [saveLog]: Error saving local access log: $e",
      );
    }
  }

  // --- Methods to query the local cache (used by AccessPointBloc) ---

  Future<CachedUser?> getCachedUser(String userId) async {
    if (!(_cachedUsersBox?.isOpen ?? false)) return null;
    try {
      // Attempt to get directly by key if userId is the key
      // return cachedUsersBox.get(userId);
      // OR Iterate through values if key is different from userId field
      return cachedUsersBox.values.firstWhere((user) => user.userId == userId);
    } catch (e) {
      // Catches StateError if not found by firstWhere
      return null;
    }
  }

  Future<CachedSubscription?> findActiveSubscription(
    String userId,
    DateTime now,
  ) async {
    if (!(_cachedSubscriptionsBox?.isOpen ?? false)) return null;
    final startOfDay = DateTime(now.year, now.month, now.day);
    try {
      // Iterate and filter in Dart - This can be slow for large boxes
      return cachedSubscriptionsBox.values.firstWhere(
        (sub) => sub.userId == userId && !sub.expiryDate.isBefore(startOfDay),
      );
    } catch (e) {
      // Catches StateError if not found
      return null;
    }
    // Consider adding Hive indexing if performance becomes an issue
  }

  // *** Uses updated CachedReservation model type, but validation logic is the same ***
  Future<CachedReservation?> findActiveReservation(
    String userId,
    DateTime now,
  ) async {
    if (!(_cachedReservationsBox?.isOpen ?? false)) return null;
    try {
      // Iterate and filter in Dart - This can be slow for large boxes
      // This logic checks if 'now' falls between the reservation start and end time
      return cachedReservationsBox.values.firstWhere(
        (res) =>
            res.userId == userId &&
            now.isAfter(res.startTime) &&
            now.isBefore(res.endTime),
        // Add more filtering based on reservation typeString if needed for validation
        // e.g., && res.typeString == ReservationType.timeBased.name
      );
    } catch (e) {
      // Catches StateError if not found
      return null;
    }
    // Consider adding Hive indexing if performance becomes an issue
  }

  // --- End Synchronization Methods ---
}
